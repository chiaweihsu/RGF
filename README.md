**RGF** is a finite-difference frequency-domain (FDFD) code in MATLAB that uses the <ins>r</ins>ecursive <ins>G</ins>reen's <ins>f</ins>unction method to solve the scattering matrix (or a portion of it) of a user-specified two-sided structure. Specifically, it solves the scalar Helmholtz equation [‚àá<sup>2</sup>+*k*<sup>2</sup>*Œµ*<sub>r</sub>(**r**)]*œà*(**r**)=0 in 2D (`cal_smatrix_RGF.m`) or 3D (`cal_smatrix_RGF_3D.m`). The 2D one is equivalent to Maxwell's equations for 2D transverse-magnetic waves with *œà*(*x*,*y*)=*E*<sub>z</sub>(*x*,*y*), and the 3D one can be used as a scalar approximation of the vectorial Maxwell's equations.

The user-specified relative permittivity profile *Œµ*<sub>r</sub>(**r**) in the scattering region can be an arbitrary real- or complex-valued matrix in 2D or 3D array in 3D, with the imaginary part describing linear gain or absorption. The scattering region is surrounded by semi-infinite homogeneous spaces on the left and right sides (with user-specified constants *Œµ*<sup>L</sup> and *Œµ*<sup>R</sup> where the input and output channels are defined. In the transverse direction(s), the user can specify periodic, Bloch periodic, or Dirichlet boundary conditions.

**RGF** solves the discretized wave equation with no additional approximation. The radiation boundary condition is implemented exactly through the retarded Green's function of a semi-infinite space on a square lattice. The scattering matrix **RGF** computes is normalized by the longitudinal flux and is exactly unitary when *Œµ*<sub>r</sub>(**r**) is real-valued. Reciprocity is also preserved exactly in the scattering matrix.

**RGF** supports complex-valued frequency, *i.e.* it can return the scattering matrix analytically continued from a real frequency to an arbitrary complex frequency.

Detailed usage and explanation are given in the first contiguous comment lines, also shown with command <code>help cal_smatrix_RGF</code> or <code>help cal_smatrix_RGF_3D</code> in MATLAB. For basic usage, see `example_script.m` and `example_script_3D.m`.

The recursive Green's function method works by slicing the system and then looping over the slices recursively to compute the side-to-side Green's function. Then the scattering matrix is obtained through the Fisher‚ÄìLee relation. The main computations are inversions and multiplications of *N*-by-*N* dense matrices, where *N*=*W*/*Œîx* in 2D and *N*=(*W*/*Œîx*)<sup>2</sup> for square cross sections in 3D, *W* is the transverse width, and *Œîx* is the discretization grid size. So the computing time scales as ùëÇ(*LW*<sup>3</sup>) in 2D and ùëÇ(*LW*<sup>6</sup>) in 3D, where *L* is the longitudinal length. The memory usage scales as ùëÇ(*LW*+*W*<sup>2</sup>) in 2D and ùëÇ(*LW*<sup>2</sup>+*W*<sup>4</sup>) in 3D. [Michael Wimmer's PhD thesis](https://epub.uni-regensburg.de/12142/) is a good reference on the recursive Green's function method.

You can cite this software as:
C. W. Hsu, RGF, https://github.com/chiaweihsu/RGF
